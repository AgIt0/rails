---
layout: lecture
title: Ruby, Have We Met
---

section.center data-background="#000"
  h1.white Ruby, Have We Met?

section.center
  p This is an over-the-top Ruby refresher

section.center
  p We'll assume you have some Ruby knowledge

section.center
  p We'll go turbo fast

section.center
  p Click <a href="/posts/hello-rails/">here</a> for extra resources

section.center data-background="#000"
  h2.white Questions

section.center
  p What is a statically typed language?

section.center
  p What is a dynamically typed language?

section.center
  p Is Ruby statically typed?

section.center
  p Does Ruby have interfaces?

section.center
  p What is an object oriented language?

section.center
  p What kind of object oriented languages you know?

section.center data-background="#000"
  h2.white ♪ RUBY, RUBY, RUBY ♪

section
  h2 Variables
  p The variables assign a name to something
  pre: code
    '
      munchies = "chunky bacon" # No need for declaration
      name = something          # The basic form

section
  h2 Variables
  p A name can point to any type
  pre: code.ruby
    '
      an_integer = 42
      a_float = 3.14
      a_string = "this is a string literal"
      an_object = Object.new

section
  h2 Variables
  p Nothing is copied, everything is referential
  pre: code.ruby
    '
      mood = "Impossible"
      downer = mood
      downer["Im"] = "I'm "
      mood # "I'm possible"

section
  h2 Variables
  p And the type can be changed midway
  pre: code.ruby
    '
      a_string = 42         # Whether that is a good idea
      a_string = Object.new # is left as an excersice ;)

section
  h2 Global Variables
  p Global variables are visible from everywhere
  pre: code.ruby
    '
      $do_you_really_need_that = "no"

section
  h2 Constants
  p Constants start with a capital letter
  pre: code.ruby
    '
      ANSWER = 42            # This is a constant!
      Europe = Continent.new # So is this!

section
  h2 Constants
  p Constants are not strictly enforced
  pre: code.ruby
    '
      >> Foo = 42
      => 42
      >> Foo = 43
      (irb):40: warning: already initialized constant Foo
      (irb):39: warning: previous definition of Foo was here
      => 43

section.center data-background="#000"
  p.white Naming is important

section.center data-background="#000"
  p.white Don't be sloppy with it

section.center data-background="#000"
  p.white We'll complain about it

section.center data-background="#000"
  p.white A lot

section.center
  img.inline src="/images/troll.png"

section.center data-background="#000"
  p.white No, really, do it

section.center data-background="#000"
  p.white I don't mind wasting slides on that

section.center data-background="#000"
  p.white Its a good message

section.center
  pre: code.ruby
    '
      everything = 42
      pi = 3.14

section
  h2 Identifiers
  ul
    li alphanumeric characters (A-Za-z0-9)
    li.fragment underscores (_)
    li.fragment may not begin with a digit (0-9)

section
  h2 Identifiers
  ul
    li identifiers that are method names may
    li.fragment end with a question mark (?)
    li.fragment end with a exclamation point (!)
    li.fragment end with equals sign (=)

section
  h2 Reserved Words
  pre: code.ruby
    '
      __FILE__  and    def       end     in      or      self   unless
      __LINE__  begin  defined?  ensure  module  redo    super  until
      BEGIN     break  do        false   next    rescue  then   when
      END       case   else      for     nil     retry   true   while
      alias     class  elsif     if      not     return  undef  yield

section
  h2 Integer
  p You can represent integers with the following literals
  pre: code.ruby
   '
     123456  # Fixnum
     123_456 # Fixnum (underscore ignored)
     -543    # Negative Fixnum

section
  h2 Integer
  p If the integer literal is too big, it will switch to a big number type
  pre: code.ruby
   '
     123456                  # Fixnum
     123_456_789_123_345_789 # Bignum (2 ** 62 onwards)

section
  h2 Integer
  p You can represent integers in hexadecimal, octal and binary forms
  pre: code.ruby
    '
      0xaabb     # Hexadecimal (Fixnum)
      0377       # Octal (Fixnum)
      -0b101_010 # Binary (Fixnum)

section
  h2 Integer
  p Fixnum and Bignum have Integer as a base class
  pre: code.ruby
    '
      >> Integer > Fixnum
      => true
      >> Integer > Bignum
      => true

section.center data-background="#000"
  p.white Everything in Ruby is an object

section.center data-background="#000"
  p.white Objects have actions

section.center data-background="#000"
  p.white universe.expand

section.center data-background="#000"
  p.white universe.kill_them_all_eventually

section.center data-background="#000"
  p.white We call those actions methods

section
  h2 Integer
  p As every object, integers respond to methods
  pre: code.ruby
    '
      >> 3.times { puts "♪ ruby ♪" }
      ♪ ruby ♪
      ♪ ruby ♪
      ♪ ruby ♪
      => 3

section
  h2 Integer
  p As every object, integers respond to methods
  pre: code.ruby
    '
      >> 16.even?
      => true

section
  h2 Floats
  p Floats can be expressed by scientific notation
  pre: code.ruby
    '
      3.1415926 # Float
      6.022e23  # Float

section
  h2 Floats
  p Floats will be floats
  pre: code.ruby
    '
      >> 0.1 + 0.2
      => 0.30000000000000004
      >> 0.1 + 0.2 == 0.3
      => false

section
  h2 Rational
  p A nice little addition
  pre: code.ruby
    '
      1/2r # Rational

section
  h2 Numbers
  p There are complex and big decimal implementations
  pre: code.ruby
    '
      >> require 'complex'
      => true
      >> Complex '1i'
      => (0+1i)

section
  h2 Numbers
  p There are complex and big decimal implementations
  pre: code.ruby
    '
      >> require 'bigdecimal'
      => true
      >> BigDecimal('125') / BigDecimal('100000')
      => #<BigDecimal:7f9c2b070610,'0.125E-2',9(36)>

section.center data-background="#000"
  p.white If you need to store money, do that in BigDecimal

section
  h2 TrueClass
  p The boolean truth
  pre: code.ruby
    '
      'He said "Hello, mister"...'
      "He said, \"There are miltiline\nstrings\"..."

section
  h2 String
  p Can be written with single and double quotes
  pre: code.ruby
    '
      'He said "Hello, mister"...'
      "He said, \"There are miltiline\nstrings\"..."

section
  h2 String
  p The two notations are not the same (unlike Python)
  pre: code.ruby
    '
      >> '\n' == "\n"
      => false
      >> "#{42}" == '#{42}'
      => false

section
  h2 String
  p Are mutable, which may surprise you
  pre: code.ruby
    '
      >> weather = "raining"
      => "raining"
      >> weather["rain"] = "snow"
      => "snow"
      >> weather
      => "snowing"

section
  h2 Symbols
  p Symbols are like lightweight strings
  pre: code.ruby
    '
      :a_symbol
      :symbols_literals_should_be_valid_identifiers!
      :"if not, they have to be written like this"
      :'which looks kinda funny'

section
  h2 Symbols
  p Interned, meaning they always yield the same object
  pre: code.ruby
    '
      >> :chunky.object_id == :chunky.object_id
      => true
      >> "chunky".object_id == "chunky".object_id
      => false

section
  h2 Symbols
  p Memory leaks, once defined they are never garbage collected
  pre: code.ruby
    '
      >> :chunky.object_id == :chunky.object_id
      => true
      >> "chunky".object_id == "chunky".object_id
      => false

section
  h2 Symbols
  p Memory leaks, once defined they are never garbage collected
  pre: code.ruby
    '
      File.open('war_and_peace.txt').each do |line|
        p line.to_sym
      end

section
  h2 Symbols
  p Not exactly true in Ruby 2.2
  pre: code.ruby
    '
      File.open('war_and_peace.txt').each do |line|
        p line.to_sym
      end

section
  h2 Symbols
  p You'll use them for internal representations

section
  h2 Symbols
  p You'll use them for enumerations

section.center
  pre: code.ruby
    '
      :east
      :west
      :south
      :north

section.center
  pre: code.ruby
    '
      :yellow
      :black
      :blue

section
  h2 The Truth
  p
    | Everything is true
    span.fragment, except nil and false

section
  h2 TrueClass
  ul
    li There is no strict Boolean class in Ruby
    li The boolean truth is represented by true, the single instance of TrueClass
  pre: code.ruby
    '
      >> true.class.ancestors
      => [TrueClass, Object, Kernerl, BasicObject]

section
  h2 FalseClass
  ul
    li There is no strict Boolean class in Ruby
    li The boolean false is represented by false, the single instance of FalseClass
  pre: code.ruby
    '
      >> false.class.ancestors
      => [FalseClass, Object, Kernerl, BasicObject]

section.center data-background="#000"
  blockquote.white I call it my billion-dollar mistake.
  p.white Tony Hoare

section
  h2 NilClass
  ul
    li Used when there is nothing to return
    li nil is represented by nil, the single instance of NilClass
  pre: code.ruby
    '
      >> def foo; end
      => :foo
      >> foo
      => nil

section
  h2 Operators
  pre
    '
      Method  Operator
      Y       [ ] [ ]=
      Y       **
      Y       ! ~
      Y       * / %
      Y       + -
      Y       >> <<
      Y       &
      Y       ^ |
      Y       <= < > >=
      Y       <=> == === != =~ !~	
              &&	
              ||
              .. ...
              ? :
              = %= { /= -= += |= &= >>= <<= *= &&= ||= **=
              defined?
              not
              or and
              if unless while until
              begin/end

section
  h2 Operators
  p Operators don't return a strict Boolean
  pre: code.ruby
    '
      >> nil || 42
      => 42
      >> nil && 42
      => nil

section
  h2 Operators
  p Evaluate as long as necessary
  pre: code.ruby
    '
      >> 42 || fail "Shh't, our lectures aren't topologically sorted anymore"
      => 42

section
  h2 If
  p The if statement executes a block of code if its condition is truthy
  pre: code.ruby
    '
      if bear.hungry?
        bear.eat
      elsif bear.thirsty?
        bear.drink
      else
        bear.dance
      end

section
  h2 If
  p The if statement executes a block of code if its condition is truthy
  pre: code.ruby
    '
      if bear.hungry? then
        bear.eat
      elsif bear.thirsty? then
        bear.drink
      else
        bear.dance
      end

section
  h2 If
  p The last executed code in an if statement is its return value
  pre: code.ruby
    '
      consequence = if bear.hungry?
                      bear.eat
                    elsif bear.thirsty?
                      bear.drink
                    else
                      bear.dance
                    end

section
  h2 If
  p Its actually an expression
  pre: code.ruby
    '
      consequence = if bear.hungry?
                      bear.eat
                    elsif bear.thirsty?
                      bear.drink
                    else
                      bear.dance
                    end

section
  h2 If
  p It returns nil if no condition matches
  pre: code.ruby
    '
      this_can_be_nil = if bear.hungry?
                          bear.eat
                        elsif bear.thirsty?
                          bear.drink
                        end


section.center data-background="#000"
  p.white Everything is an expression in Ruby

section
  h2 Postfix If
  p You can use if as an expression modifier
  pre: code.ruby
    '
      sleep if tired?

section
  h2 Unless
  p The unless statement executes a block of code if its condition is falsy
  pre: code.ruby
    '
      unless response.redirect?
        process response.body
      else
        follow response['location']
      end

section
  h2 Unless
  p There is no elsif clause
  pre: code.ruby
    '
      unless response.redirect?
        process response.body
      # There is no such thing as unlessif :)
      else
        follow response['location']
      end

section
  h2 Unless
  p Is an expression modifier
  pre: code.ruby
    '
      eat unless hungry?

section.center data-background="#000"
  p.white Unless else is hard to mentally process

section.center data-background="#000"
  p.white Use with caution

section
  h2 Case
  p A multi-way if on steroids
  pre: code.ruby
    '
      case year
      when 1850..1889
        :blues
      when 1890..1909
        :ragtime
      when 1910..1929
        :new_orlean_jazz
      when 1930..1939
        :swing
      when 1940..1950
        :bebop
      else
        :jazz
      end

section
  h2 Case
  p A multi-way if on steroids
  pre: code.ruby
    '
      case year
      when 1850..1889 then :blues
      when 1890..1909 then :ragtime
      when 1910..1929 then :new_orlean_jazz
      when 1930..1939 then :swing
      when 1940..1950 then :bebop
      else                 :jazz
      end

section
  h2 Case
  p A multi-way if on steroids
  pre: code.ruby
    '
      genre = case year
              when 1850..1889 then :blues
              when 1890..1909 then :ragtime
              when 1910..1929 then :new_orlean_jazz
              when 1930..1939 then :swing
              when 1940..1950 then :bebop
              else                 :jazz
              end

section
  h2 Case
  p The case subject can be skipped
  pre: code.ruby
    '
      case
      when (1850..1889) === year
        :blues
      when (1890..1909) === year
        :ragtime
      when (1910..1929) === year
        :new_orlean_jazz
      when (1930..1939) === year
        :swing
      when (1940..1950) === year
        :bebop
      else
        :jazz
      end

section
  h2 Case
  p It will become true, implicitly
  pre: code.ruby
    '
      case true
      when (1850..1889) === year
        :blues
      when (1890..1909) === year
        :ragtime
      when (1910..1929) === year
        :new_orlean_jazz
      when (1930..1939) === year
        :swing
      when (1940..1950) === year
        :bebop
      else
        :jazz
      end

section
  h2 Case
  p Objects responding to #=== can be used in when
  pre: code.ruby
    '
      case
      when (1850..1889) === year
        :blues
      when (1890..1909) === year
        :ragtime
      when (1910..1929) === year
        :new_orlean_jazz
      when (1930..1939) === year
        :swing
      when (1940..1950) === year
        :bebop
      else
        :jazz
      end

section
  h2 While
  p Iterates while a condition is truthy
  pre: code.ruby
    '
      while hungry?
        eat
      end

section
  h2 While
  p Is an expression modifier
  pre: code.ruby
    '
      eat while hungry?

section
  h2 Until
  p Iterates while a condition is falsy
  pre: code.ruby
    '
      untill full?
        eat
      end

section
  h2 Until
  p Is an expression modifier
  pre: code.ruby
    '
      eat until full?

section
  h2 For
  p Don't use for in Ruby
  pre: code.ruby
    '
      for color in spectrum
        color.inverse
      end

section
  h2 For
  p An anti-pattern
  pre: code.ruby
    '
      for color in spectrum
        color.inverse
      end

section
  h2 For
  p Calls #each under the hood
  pre: code.ruby
    '
      >> for letter in "abcdefg..."
      >>   say letter
      >> end
      NoMethodError: undefined method `each' for "abcdefg...":String

section
  h2 For
  p Doesn't create a closure the names leak out
  pre: code.ruby
    '
      >> for letter in "abcdefg..."
      >>   say letter
      >> end
      NoMethodError: undefined method `each' for "abcdefg...":String

section
  h2 Method
  p Defined by the keyword def
  pre: code.ruby
    '
      def eat(food)
        3.times { nom }
      end

section
  h2 Method
  p Can hold local variables
  pre: code.ruby
    '
      def just_hanging_around_creating_local_variables
        a_local_variable = 42
      end

      >> just_hanging_around_creating_local_variables
      => 42

section
  h2 Method
  p Local variables aren't visible outside the method
  pre: code.ruby
    '
      def just_hanging_around_creating_local_variables
        a_local_variable = 42
      end

      >> just_hanging_around_creating_local_variables
      => 42
      >> a_local_variable
      NameError: undefined local variable or method `a_local_variable' for main:Object

section
  h2 Method
  p Returns a value
  pre: code.ruby
    '
      def eat(food)
        3.times { nom }
        return :delicious
      end

      >> eat(:stake)
      => :delicious

section
  h2 Method
  p Returns a value early
  pre: code.ruby
    '
      def eat(food)
        return :oh_well if food == :potato

        3.times { nom }
        return :delicious
      end

      >> eat(:stake)
      => :delicious

section
  h2 Method
  p Returns a value implicitly
  pre: code.ruby
    '
      def eat(food)
        3.times { nom }
        :delicious
      end

      >> eat(:stake)
      => :delicious

section
  h2 Method
  p Always returns a value
  pre: code.ruby
    '
      def nothing
      end

      >> nothing
      => nil

section
  h2 Method
  p Can take no arguments
  pre: code.ruby
    '
      def make_some_noise
        scream
        shout
        let_it_all_out
      end

      >> make_some_noise
      => :it_sounds_like_a_cheesy_pop_song_broski

section
  h2 Method
  p Can take many arguments
  pre: code.ruby
    '
      def eat(first, second, third)
        nom first
        nom second
        nom third
      end

section
  h2 Method
  p Can take any arguments
  pre: code.ruby
    '
      def eat(*meals)
        meals.each { |meal| nom meal }
      end

      >> eat(:breakfast, :lunch, :dunner)
      => [:breakfast, :lunch, :dinner]

      >> eat(:breakfast)
      => [:breakfast]

section
  h2 Method
  p meals is an Array of the given arguments
  pre: code.ruby
    '
      def eat(*meals)
        meals.each { |meal| nom meal }
      end

      >> eat(:breakfast, :lunch, :dunner)
      => [:breakfast, :lunch, :dinner]

      >> eat(:breakfast)
      => [:breakfast]

section.center data-background="#000"
  p.white The name comes from the squashed-bug appearance on many early line printers

section.center data-background="#000"
  p.white True story

section
  h2 Method
  p The splat operator can get a little weird
  pre: code.ruby
    '
      def eat(first, *rest)
        nom first
        rest.each { |meal| nom meal }
      end

section
  h2 Method
  p Well, that's not so weird
  pre: code.ruby
    '
      def eat(first, *rest)
        nom first
        rest.each { |meal| nom meal }
      end

      >> eat(:breakfast)
      => [:breakfast]

      >> eat(:breakfast, :lunch)
      => [:breakfast, :lunch]

section
  h2 Method
  p Well, look at this
  pre.fragment: code.ruby
    '
      def eat(*everything_but, the_last_one)
        everything_but.each { |meal| nom meal }
        squash_with_your_face the_last_one
      end

      >> eat(:potatoes, :chicken, :meatballs, :ice_cream)
      => 0xDEADBEEF

      >> eat(:кифтета)
      => 0xDEADBEEF

section
  h2 Method
  p Not so weird?
  pre: code.ruby
    '
      def eat(*everything_but, the_last_one)
        everything_but.each { |meal| nom meal }
        squash_with_your_face the_last_one
      end

      >> eat(:potatoes, :chicken, :meatballs, :ice_cream)
      => 0xDEADBEEF

      >> eat(:кифтета)
      => 0xDEADBEEF

section
  h2 Method
  p Okay, okay, okay
  pre: code.ruby
    '
      def eat(*everything_but, the_last_one)
        everything_but.each { |meal| nom meal }
        squash_with_your_face the_last_one
      end

      >> eat(:potatoes, :chicken, :meatballs, :ice_cream)
      => 0xDEADBEEF

      >> eat(:кифтета)
      => 0xDEADBEEF

section
  h2 Method
  p You asked for it
  pre: code.ruby
    '
      def eat(first, *in_between, last)
        gently_taste first
        in_between.each { |meal| nom meal }
        squash_with_your_face last
      end

      >> eat(:potatoes, :ice_cream)
      => ???

section
  h2 Method
  p Can provide default values for arguments
  pre: code.ruby
    '
      def eat(meal = :bread)
        nom meal
      end

      >> eat
      => :bread

      >> eat :salad
      => :salad

section
  h2 Method
  p Can yield a block
  pre: code.ruby
    '
      def log(level)
        if level > 0
          message = yield
          puts message
        end
      end

      >> log(1) { 'FIRE!' }
      FIRE!
      => nil

      >> log(0) { 'Wha?' }
      => nil

section
  h2 Method
  p Can yield a block
  pre: code.ruby
    '
      def log(level)
        if level > 0
          message = yield
          puts message
        end
      end

      >> log(1) { 'FIRE!' }
      FIRE!
      => nil

      >> log(0) { 'Wha?' }
      => nil

section
  h2 Method
  p Can ask if a block is given
  pre: code.ruby
    '
      def log(level, message = nil)
        if level > 0
          puts block_given? ? yield : message
        end
      end

      >> log(1) do
      ..   'FIRE!'
      .. end
      FIRE!
      => nil

      >> log(1, 'FIRE!')
      FIRE!
      => nil

section
  h2 Method
  p Can yield arguments into a block
  pre: code.ruby
    '
      def create(klass)
        yield klass.new
      end

      >> create Array do |a|
      ..   a << 42
      ..   a.include? 42
      .. end
      => true

section
  h2 Method
  p Can yield many arguments into a block
  pre: code.ruby
    '
      def create(*classes)
        yield classes.map(&:new)
      end

      >> create Array, Hash do |array, hash|
      ..   puts array.class, hash.class
      .. end
      Array
      Hash
      => true

section
  h2 Method
  p Can yield many arguments into a block
  pre: code.ruby
    '
      def create(*classes)
        yield classes.map(&:new)
      end

      >> create Array, Hash do |array, hash|
      ..   puts array.class, hash.class
      .. end
      Array
      Hash
      => true

      >> create Array, Hash do |array|
      ..   puts array.class
      .. end
      Array
      => true

section.center data-background="#000"
  p.white Everything in Ruby is an object

section
  h2 Method
  p Can yield many arguments into a block
  pre: code.ruby
    '
      def create(*classes, &block)
        block.call(*classes.map(&:new))
      end

      >> create Array, Hash do |array, hash|
      ..   puts array.class, hash.class
      .. end
      Array
      Hash
      => true

      >> create Array, Hash do |array|
      ..   puts array.class
      .. end
      Array
      => true

section
  h2 Proc
  p Block are an instance of the class Proc
  pre: code.ruby
    '
      def create_block(&new_block)
        new_block.class
      end

      >> create_block { nil }.class
      => Proc

section
  h2 Proc
  p Can be created manually
  pre: code.ruby
    '
      p = proc { |*args| nil }

      >> p.call
      => nil

section
  h2 Proc
  p Can be created manually
  pre: code.ruby
    '
      p = proc do |*args|
        nil
      end

      >> p.call
      => nil

section
  h2 Proc
  p Can be called with #call #[] and #.()
  pre: code.ruby
    '
      p = proc { |*args| nil }

      >> p.call
      => nil

      >> p[]
      => nil

      >> p.()
      => nil

section.center data-background="#000"
  p.white #call

section
  h2 Proc#lambda?
  p There is a special proc called lambda

section
  h2 Proc#lambda?
  p There is a special proc called lambda
  pre: code.ruby
    '
      callable = lambda { |arg| arg }

      >> callable.call(arg)
      => nil

section
  h2 Proc#lambda?
  p There is a special proc called lambda
  pre: code.ruby
    '
      callable = -> arg { arg }

      >> callable.call(arg)
      => nil

section
  h2 Proc#lambda?
  p There is a special proc called lambda
  pre: code.ruby
    '
      callable = -> (arg) { arg }

      >> callable.call(arg)
      => nil

section
  h2 Proc#lambda?
  pre: code.ruby
    '
      >> p = proc { |a, b, c| p a, b, c }
      => #<Proc:0x007fd891a9ff30@(irb):6>
      >> p.call 1
      1
      nil
      nil
      => [1, nil, nil]
      >> l = lambda { |a, b, c| p a, b, c }
      => #<Proc:0x007fd891a86238@(irb):8 (lambda)>
      >> l.call 1
      ArgumentError: wrong number of arguments (1 for 3)

section.center
  img.inline src="/images/hackman.png"
